buildscript {
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
    }
}

plugins {
    id "de.undercouch.download" version "1.2"
}

import de.undercouch.gradle.tasks.download.Download

apply plugin: 'forge'

repositories {
    maven { 
		// The repo from which to get waila
        name "Mobius Repo"
        url "http://mobiusstrip.eu/maven"
    }
    maven { 
		// the repo from which to get NEI and stuff
        name 'ChickenBones Repo'
        url "http://chickenbones.net/maven/"
    }
}

dependencies {
    // TODO Waila
    compile "codechicken:CodeChickenLib:1.7.10-1.1.1.99:dev"
    compile "codechicken:CodeChickenCore:1.7.10-1.0.4.29:dev"
    compile "codechicken:NotEnoughItems:1.7.10-1.0.3.77:dev"
}

ext.configFile = file "build.properties"

configFile.withReader {
    def prop = new Properties()
    prop.load(it)
    project.ext.config = new ConfigSlurper().parse prop
}

ext.patch = config.patch_number
ext.resetPatch = false

if (!config.last_release.equals(config.mod_version))
{
    ext.patch = 0

    if (project.getGradle().getStartParameter().getTaskNames().contains("release"))
    {
        ext.resetPatch = true
    }
}

if (!config.dev_version.equals(config.mod_version))
{
    ext.patch = 0
}

if (project.getGradle().getStartParameter().getTaskNames().contains("release"))
{
    version = "${config.mod_version}.${ext.patch}"
}
else if (project.getGradle().getStartParameter().getTaskNames().contains("buildPublic"))
{
    version = "${config.dev_version}.${ext.patch}.public.${config.build_number}"
}
else
{
    version = "${config.dev_version}.${ext.patch}.dev.${config.build_number}"
}

group = "atomatic"
archivesBaseName = project.getName()

minecraft {
    version = config.minecraft_version + "-" + config.forge_version
	runDir = "run"
	
    replaceIn "reference/Reference.java"
    replace "@VERSION@", "${project.version}"
}

if (project.getGradle().getStartParameter().getTaskNames().contains("release"))
{
    version = "${config.minecraft_version}-${config.mod_version}.${ext.patch}"
}
else if (project.getGradle().getStartParameter().getTaskNames().contains("buildPublic"))
{
    version = "${config.minecraft_version}-${config.dev_version}.${ext.patch}.public.${config.build_number}"
}
else
{
    version = "${config.minecraft_version}-${config.dev_version}.${ext.patch}.dev.${config.build_number}"
}

processResources {
    exclude '**/*.xcf'
    from(sourceSets.main.resources.srcDirs) {
        exclude '**/*.info'
    }
	from(sourceSets.main.resources.srcDirs) {
        include '*.info'
        expand 'version': project.version, 'mcversion': config.minecraft_version
    }
}

task devJar(type: Jar, dependsOn: 'classes') {
    from(sourceSets.main.output) {
        include '**'
    }

    extension = 'jar'
    classifier = 'dev'
}

artifacts {
    archives devJar
}

task getThaumcraft(type: Download, dependsOn: "extractUserDev") {
    onlyIf {
        !file("libs/Thaumcraft-deobf-1.7.10-4.2.2.0.jar").exists()
    }
    src 'https://dl.dropboxusercontent.com/u/47135879/Thaumcraft-deobf-1.7.10-4.2.2.0.jar'
    dest file("libs/Thaumcraft-deobf-1.7.10-4.2.2.0.jar")
    mustRunAfter "deobfBinJar"
    mustRunAfter "repackMinecraft"
}

task getBaubles(type: Download, dependsOn: "getThaumcraft") {
    onlyIf {
        !file("libs/Baubles-deobf-1.7.10-1.0.1.10.jar").exists()
    }
    src 'https://dl.dropboxusercontent.com/u/47135879/Baubles-deobf-1.7.10-1.0.1.10.jar'
    dest file("libs/Baubles-deobf-1.7.10-1.0.1.10.jar")
    mustRunAfter "deobfBinJar"
    mustRunAfter "repackMinecraft"
}

tasks.setupDevWorkspace.dependsOn getBaubles
tasks.setupDecompWorkspace.dependsOn getBaubles

task handleVersion {
    onlyIf {
        !project.getGradle().getStartParameter().getTaskNames().contains("buildPublic")
    }

    doLast {
        config.build_number = (config.build_number.toString().toInteger()) + 1
        configFile.withWriter {
            config.toProperties().store(it, "")
        }

        if (project.resetPatch)
        {
            config.patch_number = 1
            configFile.withWriter {
                config.toProperties().store(it, "")
            }

            config.last_new_release = true
            configFile.withWriter {
                config.toProperties().store(it, "")
            }

            config.last_release = config.mod_version
            configFile.withWriter {
                config.toProperties().store(it, "")
            }
        }
        else if (project.getGradle().getStartParameter().getTaskNames().contains("release"))
        {
            config.patch_number = (config.patch_number.toString().toInteger()) + 1
            configFile.withWriter {
                config.toProperties().store(it, "")
            }

            config.last_new_release = false
            configFile.withWriter {
                config.toProperties().store(it, "")
            }

            config.last_release = config.mod_version
            configFile.withWriter {
                config.toProperties().store(it, "")
            }
        }

        def dev = config.dev_version.toString().tokenize('.');
        def ver = config.mod_version.toString().tokenize('.');

        if ((dev.get(0).toInteger() < ver.get(0).toInteger()) || (dev.get(1).toInteger() < ver.get(1).toInteger()))
        {
            config.dev_version = config.mod_version
            configFile.withWriter {
                config.toProperties().store(it, "")
            }
        }
    }
}

tasks.build.dependsOn handleVersion

task buildPublic(dependsOn: ['build', 'reobf', 'devJar']) {
    doLast {
        logger.lifecycle "I think I'm done"
    }
}

task release(dependsOn: ['build', 'reobf', 'devJar']) {
    doLast {
        logger.lifecycle "I think I'm done"
    }
}
